# 메모리 관리 전략

  ## 배경
 각각의 프로세스는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리공간에 접근할 수 없는 제한이 걸려있다. 단지 운영체제만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않는다.

  ### swapping
  메모리의 관리를 위해 사용되는 기법, 
  다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치(e.g. 하드디스크)로 내보내고 다른 프로세스에 메모리를 할당함
  
  ### 단편화(Fragmentaion)
  프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할 만큼의 작은 자유공간들이 늘어가게 되는데, 이것이 단편화이다,
    - 외부 단편화
      메모리 공간 중 사용하지 못하게 되는 일부분(e.g. 프로세스와 프로세스 사이)
    - 내부 단편화
      프로세스가 사용하는 메모리 공간에 포함되는 남는 부분(할당받은 메모리에서 사용하지 않는 부분)
<img src='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcnqRKG%2Fbtq414Dp7eS%2Ff8zGXr8jZLUEDuwVkT4YT0%2Fimg.png'>

  ### 압축
  외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아 사용, 효율이 좋지 않음

  ## 페이징(Paging) - 고정크기
  하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 깨는 메모리 관리 방법
  물리 메모리는 Frame이라는 고정된 크기로 분리되고 논리 메모리(프로세스가 점유하는)는 page라고 불리는 고정 크기 블록으로 분리됨. 페이징을 통해 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절하게 배치됨으로 외부 단편화 해결 하나의 프로세스가 사용하는 공간은 여러 페이지로 나뉘어 관리되고 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping되어 저장된다.

단점: 역으로 내부단편화의 비중이 증가. page에 여유공간이 남게 되는 경우가 많기 때문 

  ## 세그멘테이션(Semgentation) - 가변 크기
  서로 다른 크기의 논리적 단위인 세그먼트로 분활함.
  내부 단편화 문제를 해소하기 위한 방법. 메모리 상 효율이 개선되고 동적 분할을 통한 오버헤드가 감소함
  
  단점: 외부단편화 문제 해결 불가, 서로 다른 크기의 스그먼트들이 적재되고 제거되다보면 빈 공간이 많은 수의 작은 조각으로 나뉘어 사용하지 못하게 되기 떄문
  
  
# 가상메모리
다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다. 가상메모리는 프로세스 전체가 메모리 내에 올라오지 않더라도  실행이 가능하도록 하는 기법이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다. 

 ## 배경
 메모리 용량보다 큰 프로그램을 실행시키기 위해, 또한 여러 프로그램을 동시에 돌리기 위해
 
 ##역할
 가상 메모리는 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것. 작은 메모리를 가지고도 얼마든지 큰 가상 메모리 공간을 프로그래머에게 제공할 수 있다. 
 
 ## 페이지 공유
 가상 메모리는 프로세스 간의 페이지 공유를 가능하게 한다. 물리메모리에 올라와 공유되고 있는 것을 유저들 입장에서는 자신만의 가상 메모리에 저장된 것 처럼 보이도록 하는 것이다.
 
 ## 방법
 물리 메모리가 모두 사용 중일 경우의 메모리 교체 흐름이다.
 1. 디스크에서 필요한 페이지의 위치를 찾는다
 2. 빈 페이지 프레임을 찾는다,
 3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페ㅣ지를 읽어 오고, 프레임 테이블을 수정한다.
 4. 사용자 프로세스 재시작
 
 간단하게 정리하면 필요한 페이지의; 부재로 디스크에서 페이지를 가져올 때, 물리 메모리에 자리가 부족할 경우, 물리 메모리 상에서 희생 페이즈를 알고리즘을 통해 선택하고, 희생페이지를 디스크로 옮긴 후, 그 자리에 필요한 페이지를 올리게 된다.
 
 ### 페이지 교체 알고리즘
 1.가장 간단한 방법으로는 들어온 순서대로 페이지 교체 시점으로 먼저 나가게 된다.
  장점은 구현이 쉽고 이해가 쉽다.
  단점은 오래된 페이지가 항상 불필요한 정보가 아닐수 있다.
 2. 최적 페이지 교체하는 방법으로 가장 사용빈도가 적은 것을 사용
  장점 가장 낮은 페이지 부재율을 보장함
  단점 구현의 어려움이 있음
 
 
 # 캐시의 지역성
 캐시 메모리는 속도가 빠른 장치와 느린 장치 간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리이다.
 
 ## 적중 & 실패
 CPU는 메모리에 접근하기 전에 캐시 메모리를 먼저 들러 찾고자 하는 데이터가 있는지 확인한다.
 - 필요한 데이터를 찾았을때 : 적중(Cache Hit)
 - 필요한 데이터를 찾지 못했을 때 : 실패(Cache Miss)
  CPU는 데이터를 가져오기 위해서 캐시 메모리 > 주기억장치(Memory) > 보조기억장치(Disk) 순으로 접근한다.
<img src='https://mangchhe.github.io/assets/postImages/CacheMemory/dataFlowChart.png'>

## 공간 지역성 & 시간 지역성
캐시 메모리에 최대한 많은 데이터를 넣으면 좋은 성능을 낼 수 있겠지만 그게 가능했다면 주기억장치와 같은 저장 매체는 필요로 하지 않았을 것이다. 담을 수 있는 데이터는 많지 않기 때문에 자주 사용될 것 같은 데이터를 담는 것이 좋다. 이때 사용하는 것이 지역성이다


지역성에는 세가지가 존재한다
1. 시간적 지역성 : 사용되었던 데이터가 가까운 시일 내에 한 번 더 사용될 가능성이 큰 성질
2. 공간적 지역성 : 사용되었던 데이터의 인접 데이터가 사용될 가능성이 큰 성질
3. 순차적 지역성 : 분기가 발생하지 않는 이상 순차적으로 실행될 가능성이 큰 성질
 
